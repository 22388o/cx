# Compiler Development

Goyacc is a version of yacc generating Go programs.

<br />

Installation
<br />
$ go get modernc.org/goyacc
<br />
Documentation: godoc.org/modernc.org/goyacc
<br />

When submitting changes to CX core, the development team uses Git pull requests for staging. Submit changes as a pull request and after review by the development team additional changes may be suggested prior to merging.

# CX Compiler Stages

The compiler creates an AST first by using regular expression parsing (found in [parse.go](https://github.com/skycoin/cx/blob/develop/cxgo/cxlexer/parse.go) which structures the AST to include all package declarations, import chains, struct declarations, and globals, skipping over comments. This preliminary stage of parsing aids further stages since the structure of a CX repository and the names of custom types are already known. 

After this preliminary stage, the first parsing stage compiles function primitives and types, along with the structure of their parameters and global variables. This stage also finalizes compilation of structs and ensures packages and their imports are correct. This uses `goyacc` for parsing and creates a chain of tokens for the parser using an in-house lexer known as `Lexer`. 

The second parsing stage fully compiles functions and all expressions. This functions similarly to the first stage, using `Lexer` and `goyacc`, but also uses `cxgo/actions` for each action the parser should take after encountering a valid syntactical production rule. These work entirely to validate program structure and to build the AST for a CX program. 

Finally, the `main` function and invisible `*init` functions are created, the latter of which acts as an initializer for global variables. 

The lifetime of a CX program in depth is given here:
1. [lexerStep0](https://github.com/skycoin/cx/blob/55391915c2fac1701d4af0f2567410ccbb9ad734/cxgo/cxlexer/parse.go#L84) - here, a copy of the source code is passed in as an array of strings, along with the file names. A series of regular expressions are compiled to check for various things. Finally, the source code is iterated over, and for each file, we iterate over a scanner of the file. Then, for each successful scan:
    1. We first check if we’re in a comment or not. If we are, we continue scanning and ignore the following steps.
    2. Next, we check if this current line contains a package declaration. If so, then we check if the program has added a package with that name. If not, then we add that package to the CXProgram (PRGM0, basically the main program). Remember, now that package is the current package.
    3. We do the same thing for structures.
2. We now start a second iteration over the source code, the same as before, and for each successful scan, after checking for comments like before:
    1. We check for import statements, and for each one, add the CXPackage to the Imports of the active CXPackage.
    2. We check for global variables, and for each one found, add it to Globals of the active CXPackage. Additionally, we now have an inBlock counter, and when positive, it means we are inside a block, and should not add any variable declarations to globals. Things like variable type, etc will be added in later steps.
3. We can now do the third step, which is the first call to the parser (cxgo0). This parses function declarations and builds global variables fully, including custom types (CXStructs) and packages.
4. As an intermediate step, after the program has been selected for and after the program has been checked for any compile or parsing errors, os arguments are added to the program. 
    1. The OS package builtin for CX is grabbed, and for all globals in the OS package not currently added to said package, they are declared, and DeclareGlobalInPackage is called on them, after getting rid of the first two arguments, presumed to be the call to CX and the name of the program to call.
5. Finally, the program is fully parsed by the cxgo/parser code.
6. After all of this, we check if a main package exists. If not, one is automatically generated by CX, and a blank main function too. We also create something called the `*init` function, which is an automatically generated entry-point function for CX, which initializes all the global variables with the values they need to be initialized with, since the CX compiler doesn’t automatically set the data segment with said values.
7. Finally, the program is executed by running RunCompiled. This function takes two arguments - nCalls and args - which correspond to the initial number of calls made and the OS arguments to parse into the entry point function (main). For our intents and purposes, nCalls is zero, and args is already verified.
8. The program is selected, and the heap is initialized to its starting size, and the random seed for random functions is initialized. Additionally, untilEnd (saying whether or not to run until end) is set to true, since nCalls is zero. Finally, prior to beginning, the main package is selected.
9. If CallStack’s first CXCall’s operator is nil, that means `*init` needs to be executed. (We can safely check this since CallStack is already guaranteed to be a non-zero length array of default value structures). `*init` is selected, and made into a call with the appropriate maker, with StackPointer set to `*init`’s Size. `*init` is first called, then, obviously, it loads all the expressions onto the callstack to initialize the global variables. After this finishes, the call state is fully reset.
10. The main function is selected, and made into a call, with the frame pointer being set and the stack pointer updated by the main function’s Size (which, remember, is the size of the inputs and outputs of the function). 
11. For each `os` argument, the argument is initialized onto the heap.
12. Finally, CXProgram.Run is called. While the program isn’t terminated, and while untilEnd isn’t set or while nCalls isn’t zero, and while the CallCounter isn’t ever greater than untilCall (the final call):
    1. A call is grabbed from the CallStack at CallCounter
    2. Check for stackoverflow
    3. While not untilEnd, each expression is executed and popped from the CallStack. (etc...)


