/(\r\n|\r|\n)/ {
	lval.line++
}
/(\t| )/ {
	/* skip blanks and tabs */
}
/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|\/\/[^\n\r]*/ {
	/* skip comments */
	lval.line = lval.line + countNewLines([]byte(yylex.Text()))
}
/bool/                    { lval.tok = yylex.Text(); return BOOL }
/byte/                    { lval.tok = yylex.Text(); return BYTE }
/break/                   { return BREAK }
/case/                    { return CASE }
/const/                   { return CONST }
/continue/                { return CONTINUE }
/default/                 { return DEFAULT }
/else/                    { return ELSE }
/enum/                    { return ENUM }
/f32/                     { lval.tok = yylex.Text(); return F32 }
/f64/                     { lval.tok = yylex.Text(); return F32 }
/for/                     {return FOR}
/goto/                    {return GOTO}
/i8/                      {lval.tok = yylex.Text(); return I8}
/i16/                     {lval.tok = yylex.Text(); return I16}
/i32/                     {lval.tok = yylex.Text(); return I32}
/i64/                     {lval.tok = yylex.Text(); return I64}
/if/                      {return IF}
/return/                  {return RETURN}
/str/                     {return STR}
/struct/                  {return STRUCT}
/switch/                  {return SWITCH}
/type/                    {return TYPE}
/ui8/                     {lval.tok = yylex.Text(); return UI8}
/ui16/                    {lval.tok = yylex.Text(); return UI16}
/ui32/                    {lval.tok = yylex.Text(); return UI32}
/ui64/                    {lval.tok = yylex.Text(); return UI64}
/union/                   {return UNION}
/&/          { lval.tok = yylex.Text(); return REF_OP }
/\+/         { lval.tok = yylex.Text(); return ADD_OP }
/-/          { lval.tok = yylex.Text(); return SUB_OP }
/\*/         { lval.tok = yylex.Text(); return MUL_OP }
/\//         { lval.tok = yylex.Text(); return DIV_OP }
/%/          { lval.tok = yylex.Text(); return MOD_OP }
/>>=/                     {return RIGHT_ASSIGN}
/<<=/                     {return LEFT_ASSIGN}
/\+=/                     {return ADD_ASSIGN}
/-=/                      {return SUB_ASSIGN}
/\*=/                     {return MUL_ASSIGN}
/\/=/                     {return DIV_ASSIGN}
/%=/                      {return MOD_ASSIGN}
/&=/                      {return AND_ASSIGN}
/\^=/                     {return XOR_ASSIGN}
/\|=/                      {return OR_ASSIGN}
/>>/                      {return RIGHT_OP}
/<</                      {return LEFT_OP}
/\+\+/                    {return INC_OP}
/--/                      {return DEC_OP}
/&&/                      {return AND_OP}
/||/                      {return OR_OP}
/<=/                      {return LE_OP}
/>=/                      {return GE_OP}
/==/                      {return EQ_OP}
/!=/                      {return NE_OP}
/;/                       { return SEMICOLON }
/!/                       { return EXCL }
/\[/                      { return LBRACK }
/\]/                      { return RBRACK }
/\(/                      { return LPAREN }
/\)/                      { return RPAREN }
/\{/                      { return LBRACE }
/\}/                      { return RBRACE }
/\./                      { return PERIOD }
/,/                       { return COMMA }
/=/                       { return ASSIGN }
/:=/                      { return CASSIGN }
/(:dl)|(:dLocals)/        { return DSTATE     }
/(:ds)|(:dStack)/         { return DSTACK     }
/(:dProgram)|(:dp)/       { return DPROGRAM   }
/:package/                { return SPACKAGE   }
/:struct/                 { return SSTRUCT    }
/:func/                   { return SFUNC      }
/:rem/                    { return REM        }
/:step/                   { return STEP       }
/:tStep/     { return TSTEP      }
/:pStep/     { return PSTEP      }
/:aff/       { return AFF        }
/package/    { return PACKAGE    }
/type/       { return TYPSTRUCT  }
/struct/     { return STRUCT     }
/return/     { return RETURN     }
/goto/       { return GOTO       }
/if/         { return IF         }
/for/        { return FOR        }
/func/       { return FUNC       }
/clauses/    { return CLAUSES    }
/expr/       { return EXPR       }
/def/        { return DEF        }
/field/      { return FIELD      }
/input/      { return INPUT      }
/output/     { return OUTPUT     }
/import/     { return IMPORT     }
/var/        { return VAR        }
/"([^"]*)"/ { /* " */
	lval.tok = yylex.Text()
	lval.line = lval.line + countNewLines([]byte(lval.tok))
	return STRING_LITERAL
}
/true/ {
	lval.i32 = int32(1)
	return BOOLEAN_LITERAL
}
/false/ {
	lval.i32 = int32(0)
	return BOOLEAN_LITERAL
}
/-?[0-9]+B/ {
	result ,_ := strconv.ParseInt(yylex.Text()[:len(yylex.Text()) - 1], 10, 8)
	lval.byt = byte(result)
	return BYTE_LITERAL
}
/-?[0-9]+L/ {
	result ,_ := strconv.ParseInt(yylex.Text()[:len(yylex.Text()) - 1], 10, 64)
	lval.i64 = int64(result)
	return LONG_LITERAL
}
/-?[0-9]+\.[0-9]*D/ {
	result ,_ := strconv.ParseFloat(yylex.Text()[:len(yylex.Text()) - 1], 64)
	lval.f64 = float64(result)
	return DOUBLE_LITERAL
}
/-?[0-9]+/ {
	result ,_ := strconv.Atoi(yylex.Text())
	lval.i32 = int32(result)
	return INT_LITERAL
}
/-?[0-9]+\.[0-9]*/ {
	result ,_ := strconv.ParseFloat(yylex.Text(), 32)
	lval.f32 = float32(result)
	return FLOAT_LITERAL
}
/[_a-zA-Z][_a-zA-Z0-9]*/ {
	lval.tok = yylex.Text()
	return IDENTIFIER
}
//
package main
import (
	"os"
	"os/exec"
	"fmt"
	"bytes"
	"time"
	"io/ioutil"
	"strconv"
	"encoding/json"

	//"regexp"
	
//	"flag"

	"net"
	"net/http"
	
	"runtime"
	//"runtime/debug"

	//"github.com/skycoin/viscript/signal"
	
	//"github.com/skycoin/skycoin/src/cipher/encoder"
//"github.com/skycoin/cx/cx/cx0"
	. "github.com/skycoin/cx/src/base"
)

func countNewLines (s []byte) int {
	count := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '\n' {
			count++
		}
	}
	return count
}

func readline (fi *bufio.Reader) (string, bool) {
	//s, err := fi.ReadString(';')
	s, err := fi.ReadString('\n')
	
	if err != nil {
		return "", false
	}
	return s, true
}

func unsafeEval (code string) (out string) {
	var lexer *Lexer
	defer func() {
		if r := recover(); r != nil {
			out = fmt.Sprintf("%v", r)
			lexer.Stop()
		}
	}()
	
	// storing strings sent to standard output
	old := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w
	
	lineNo = 0
	
	b := bytes.NewBufferString(code)
	lexer = NewLexer(b)
	yyParse(lexer)

	if err := prgrm.Run(); err != nil {
		prgrm = MakeProgram(1024, 1024, 1024)
		return fmt.Sprintf("%s", err)
	}

	outC := make(chan string)
	go func() {
		var buf bytes.Buffer
		io.Copy(&buf, r)
		outC <- buf.String()
	}()
	
	w.Close()
	os.Stdout = old // restoring the real stdout
	out = <-outC

	prgrm = MakeProgram(1024, 1024, 1024)
	return out
}

func Eval (code string) string {
	runtime.GOMAXPROCS(2)
	ch := make(chan string, 1)

	var result string
	
	go func() {
		result = unsafeEval(code)
		ch <- result
	}()

	timer := time.NewTimer(20 * time.Second)
	defer timer.Stop()

	select {
	case <-ch:
		return result
	case <-timer.C:
		prgrm = MakeProgram(1024, 1024, 1024)
		return "Timed out."
	}
}

type SourceCode struct {
	Code string
}

func WebMode () {
	host := ":5336"

	mux := http.NewServeMux()
	
	mux.Handle("/", http.FileServer(http.Dir("./dist")))
	
	mux.HandleFunc("/eval", func(w http.ResponseWriter, r *http.Request) {
		defer r.Body.Close()
		var b []byte
		var err error
		if b, err = ioutil.ReadAll(r.Body); err != nil {
			http.Error(w, err.Error(), 500)
			return
		}
		
		var source SourceCode
		if err := json.Unmarshal(b, &source); err != nil {
			http.Error(w, err.Error(), 500)
			return
		}

		if err := r.ParseForm(); err == nil {
			fmt.Fprintf(w, "%s", Eval(source.Code))
		}
	})

	if listener, err := net.Listen("tcp", host); err == nil {
		fmt.Println("Starting CX web service on http://127.0.0.1:5336/")
		http.Serve(listener, mux)
	}
}

func parseFile (fileName string) {
	sourceCode, err := os.Open(fileName)
	if err != nil {
		panic(fmt.Sprintf("Couldn't read file."))
	}
	yyParse(NewLexer(sourceCode))
}

func help () {
	fmt.Printf(`Usage: cx [options] [source-files]

CX options:
-b, --base                        Generate a "out.cx.go" file with the transcompiled CX Base source code.
-c, --compile                     Generate a "out" executable file of the program.
-co, --compile-output FILENAME    Specifies the filename for the generated executable.
-h, --help                        Prints this message.
-r, --repl                        Loads source files into memory and starts a read-eval-print loop.
-w, --web                         Start CX as a web service.

Signal options:
-signal-client                   Run signal client
-signal-client-id UINT           Id of signal client (default 1)
-signal-server-address STRING    Address of signal server (default "localhost:7999")

Notes:
* Options --compile and --repl are mutually exclusive.
* Option --web makes every other flag to be ignored.
`)
}

func (yylex Lexer) Error (e string) {
	if inREPL {
		fmt.Printf("syntax error: %s\n", e)
	} else {
		fmt.Printf("%d: syntax error: %s\n", yylex.Line() + 1, e)
	}
	
	yylex.Stop()
}

func getWorkingDirectory (file string) string {
	var c int = len(file) - 1
	for ; c > 0; c-- {
		if file[c - 1] == os.PathSeparator {
			break
		}
	}
	return file[:c]
}

func main () {
	runtime.LockOSThread()
	runtime.GOMAXPROCS(2)

	//debug.SetGCPercent(-1)

	//Foo()
	//Bar()

	//signal.Listen("0.0.0.0:7999")

	args := os.Args[1:]
	var sourceCode []*os.File

	if len(args) == 0 {
		replMode = true
	}

	flagMode := false
	var compileOutput string = "o"
	for i, arg := range args {
		if arg == "--web" || arg == "-w" {
			webMode = true
			flagMode = true
			continue
		}
		if arg == "--repl" || arg == "-r" {
			replMode = true
			flagMode = true
			continue
		}
		if arg == "--base" || arg == "-b" {
			baseOutput = true
			flagMode = true
			continue
		}
		if arg == "--compile" || arg == "-c" {
			compileMode = true
			baseOutput = true
			flagMode = true
			continue
		}
		if arg == "--compile-output" || arg == "-co" {
			compileOutput = args[i+1]
			continue
		}
		if arg == "--help" || arg == "-h" {
			helpMode = true
			flagMode = true
			continue
		}
		// viscript options
		if arg == "-signal-client" || arg == "-signal-client-id" || arg == "-signal-server-address" {
			continue
		}
		if i > 0 && (args[i-1] == "-signal-client-id" || args[i-1] == "-signal-server-address") {
			continue
		}
		if !flagMode {
			file, err := os.Open(arg)
			if err != nil {
				panic(fmt.Sprintf("Couldn't read file."))
			}
			sourceCode = append(sourceCode, file)
		}
	}

	if helpMode {
		help()
		return
	}

	if webMode {
		WebMode()
		return
	}

	if compileMode && replMode {
		fmt.Println("Error: Options --compile and --repl are mutually exclusive.")
		return
	}

	//cx0.PRGRM = prgrm

	sourceCodeCopy := make([]string, len(sourceCode))
	for i, source := range sourceCode {
		tmp := bytes.NewBuffer(nil)
		io.Copy(tmp, source)
		sourceCodeCopy[i] = string(tmp.Bytes())
	}

	//allSC := strings.Join(sourceCodeCopy, "")
	// cx0.Parse(allSC)
	// prgrm = cx0.PRGRM
	
	// parsing all source code files
	for i, source := range sourceCodeCopy {
		fileName = args[i]
		b := bytes.NewBufferString(source)
		yyParse(NewLexer(b))
	}
	
	lineNo = 0

	//prgrm.Compile(false)

	if replMode || len(sourceCode) == 0 {
	mod := MakePackage(MAIN_PKG)
		prgrm.AddPackage(mod)
		fn := MakeFunction("main")
		mod.AddFunction(fn)

		replTargetFn = "main"
		//repl()
	} else if !compileMode && !baseOutput && len(sourceCode) > 0 {
		if err := prgrm.Run(); err != nil {
			fmt.Println(err)
			//repl()
		}
	}
	
if baseOutput {
	//prgrm.Compile(true)
}
	if compileMode {
	baseFilename := fmt.Sprintf("%s.go", compileOutput)
		build := exec.Command("go", "build", baseFilename)
		build.Run()
		removeBase := exec.Command("rm", baseFilename)
		removeBase.Run()
	}
}
