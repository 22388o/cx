%\vfill\eject
\chapter{Affordances}
\label{affordances}

Affordances are part of a CX mechanism that informs the programmer or the CX
program itself about the possible actions that can be performed over a
CX element. For example, if a function call (a CX expression) requires
two arguments as input parameters, and only one has been provided, it
is said that the expression can afford another argument to be added to
its collection of arguments. In this case, a programmer can make a
call to a GetAffordances function to obtain a list of possible CX
elements that can act as an argument to the given expression.

However, the GetAffordances function, in this case, should restrict
the list of affordances to the operator's required type for that
particular input. This means that if the operator's second input type
is i32, only arguments, identifiers, globals or function calls which
return i32 outputs (note that this is not an exhaustive list of the
possibilities) could be indicated as candidates to be appended to the
expression's collection of arguments.

At least, the following CX elements can be asked for affordances: the CX program
itself, modules, structs, functions, and expressions. In its most
basic functionality:

\begin{itemize}
\item \textbf{Program affordances} should enlist the action for
  appending a new module.
\item \textbf{Module affordances} should enlist the actions for adding
  a new definition, for each of the available types to the module
  (primitive types, and user defined types via structs); adding a new
  import, excluding those that have already been imported; adding a
  new function; and adding a new struct.
\item \textbf{Struct affordances} should enlist the action for
  appending a new field, for each of the available types to the module
  (primitive types, and user defined types via structs).
\item \textbf{Function affordances} should enlist the actions for
  appending new input or output parameters, for each of the available
  types to the module (primitive types, and user defined types via
  structs); and adding a new expression, where its operator can be any
  of the functions defined in its parent module or in any of the
  imported modules by its parent module.
\item \textbf{Expression affordances}, perhaps the most complex type
  of affordances, should enlist actions for adding new arguments and
  new output names. Compared to the other type of affordances,
  expression affordances are complex to determine because there are
  many types of CX elements that can act as an argument to an
  expression. Likewise, output names could be virtually any identifier
  in a CX program which matches the required type by an input
  parameter in a given expression. The elements that could act as
  arguments include, and are not limited to, input parameter names,
  output parameter names, global and local definitions, literals, and
  expressions. The elements that could act as output names include,
  and are not limited to, input parameter names, output parameter
  names, and global and local definitions.

\end{itemize}

How the affordance mechanism chooses a name or a value for those
elements which require either or both of those is not specified. A CX
program could ask the programmer for a desired name or value, or the
program could choose a randomly generated name. In any case, the
mechanism must ensure that names be unique for new elements, and that
values comply with the element's required type.

More detailed descriptions of each of the types of affordances can be
found in the next Subsections.

\section{Program Affordances}
\label{program-affordances}

The most basic action a program can afford is the addition of new
modules. Nevertheless, program affordances have the potential to
enlist any action that could be performed to any element contained in
a CX program.

As a CX program element also contains a reference to the call stack,
affordances could enlist possible actions related to them. For
example, a program can afford to go back \textit{N} steps in the call
stack, or be executed \textit{N} steps. Other more obscure actions
could be afforded by the call stack element, such as changing local
definitions in previous, open calls, change the return address of a
call, etc.

Another kind of program affordances would be to change the program's
output. Instead of sending the output argument to the operating
system, it could be sent to another device.

\section{Module Affordances}
\label{module-affordances}

A CX module element

\section{Struct Affordances}
\label{struct-affordances}

\section{Function Affordances}
\label{function-affordances}

\section{Expression Affordances}
\label{expression-affordances}



\section{Filtering Affordances}
\label{filtering-affordances}

\section{Applying Affordances}
\label{affordance-filtering}
