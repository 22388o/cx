\chapter{Standard Libraries}
\label{stdlibraries}

%% Note, this is used to generate stdmod.tex.  The bindings could be
%% extracted automatically from the document, but this lets us choose
%% the ordering and optionally format manually where needed.

This section lists the exports provided by the standard libraries.  The
libraries are factored so as to separate features which might not be
supported by all implementations, or which might be expensive to load.

\subsection{addI32, addI64, addF32, addF64}

\textbf{Syntax:}

\textbf{addI32} i32 i32 $=>$ i32

\textbf{addI64} i64 i64 $=>$ i64

\textbf{addF32} f32 f32 $=>$ f32

\textbf{addF64} f64 f64 $=>$ f64

\textbf{Description:}

Returns the sum of the two numbers provided. If the two numbers are of
different type, an error must be signaled, as type conversions are
explicit in CX.

\textbf{Examples:}

\begin{lstlisting}
sum := addI32(3, -5)
addI64(i32ToI64(3), i32ToI64(5))
printF32(addF32(3.5, 3.7))
\end{lstlisting}

\subsection{subI32, subI64, subF32, subF64}

\textbf{Syntax:}

\textbf{subI32} i32 i32 $=>$ i32

\textbf{subI64} i64 i64 $=>$ i64

\textbf{subF32} f32 f32 $=>$ f32

\textbf{subF64} f64 f64 $=>$ f64

\textbf{Description:}

Returns the difference of the two numbers provided, and the order of
the arguments is equivalent to the order in a traditional infix
substraction. If the two numbers are of different type, an error must
be signaled, as type conversions are explicit in CX.

\textbf{Examples:}

\begin{lstlisting}
diff := subI32(10, 5)
subI64(i32ToI64(3), i32ToI64(5))
printF32(subF32(10.0, 5.0))
\end{lstlisting}

\subsection{mulI32, mulI64, mulF32, mulF64}

\textbf{Syntax:}

\textbf{mulI32} i32 i32 $=>$ i32

\textbf{mulI64} i64 i64 $=>$ i64

\textbf{mulF32} f32 f32 $=>$ f32

\textbf{mulF64} f64 f64 $=>$ f64

\textbf{Description:}

Returns the product of the two numbers provided. If the two numbers
are of different type, an error must be signaled, as type conversions
are explicit in CX.

\textbf{Examples:}

\begin{lstlisting}
product := mulI32(-1, -20)
mulI64(i32ToI64(0), i32ToI64(3))
printF32(mulF32(1.1, 1.1))
\end{lstlisting}

\subsection{divI32, divI64, divF32, divF64}

\textbf{Syntax:}

\textbf{divI32} i32 i32 $=>$ i32

\textbf{divI64} i64 i64 $=>$ i64

\textbf{divF32} f32 f32 $=>$ f32

\textbf{divF64} f64 f64 $=>$ f64

\textbf{Description:}

Returns the division of the two numbers provided. If the two numbers
are of different type, an error must be signaled, as type conversions
are explicit in CX. If the denominator (second argument) is 0, a
\textit{division by 0} error must be raised, and the program's
execution must be halted.

\textbf{Examples:}

\begin{lstlisting}
div := divI32(10, 2)
divI64(i32ToI64(30), i32ToI64(0))
printF32(divF32(1.1, 1.1))
\end{lstlisting}

\subsection{modI32, modI64}

\textbf{Syntax:}

\textbf{modI32} i32 i32 $=>$ i32

\textbf{modI64} i64 i64 $=>$ i64

\textbf{Description:}

Returns the modulus of the two numbers provided. If the two numbers
are of different type, an error must be signaled, as type conversions
are explicit in CX. If the denominator (second argument) is 0, a
\textit{division by 0} error must be raised, and the program's
execution must be halted.

\textbf{Examples:}

\begin{lstlisting}
rem := modI32(10, 2)
modI64(i32ToI64(30), i32ToI64(0))
\end{lstlisting}

\subsection{printStr, printBool, printByte, printI32, printI64, printF32,
  printF64, printBoolA, printByteA, printI32A, printI64A, printF32A, printF64A}

\textbf{Syntax:}

\textbf{printStr} str $=>$ str

\textbf{printBool} bool $=>$ bool

\textbf{printByte} byte $=>$ byte

\textbf{printI32} i32 $=>$ i32

\textbf{printI64} i64 $=>$ i64

\textbf{printF32} f32 $=>$ f32

\textbf{printF64} f64 $=>$ f64

\textbf{printBoolA} []bool $=>$ []bool

\textbf{printByteA} []byte $=>$ []byte

\textbf{printI32A} []i32 $=>$ []i32

\textbf{printI64A} []i64 $=>$ []i64

\textbf{printF32A} []f32 $=>$ []f32

\textbf{printF64A} []f64 $=>$ []f64

\textbf{Description:}

A print function exists for each of the primitive types. These
functions display the argument's value to the terminal. In the case of
arrays, the values are enclosed in brackets and separated by
spaces. Each of the print functions return their argument.

\textbf{Examples:}

\begin{lstlisting}
printStr(``Hello world!'')
addI32(printI32(30), printI32(50))
\end{lstlisting}

\subsection{idStr, idBool, idByte, idI32, idI64, idF32,
  idF64, idBoolA, idByteA, idI32A, idI64A, idF32A, idF64A}

\textbf{Syntax:}

\textbf{idStr} str $=>$ str

\textbf{idBool} bool $=>$ bool

\textbf{idByte} byte $=>$ byte

\textbf{idI32} i32 $=>$ i32

\textbf{idI64} i64 $=>$ i64

\textbf{idF32} f32 $=>$ f32

\textbf{idF64} f64 $=>$ f64

\textbf{idBoolA} []bool $=>$ []bool

\textbf{idByteA} []byte $=>$ []byte

\textbf{idI32A} []i32 $=>$ []i32

\textbf{idI64A} []i64 $=>$ []i64

\textbf{idF32A} []f32 $=>$ []f32

\textbf{idF64A} []f64 $=>$ []f64

\textbf{Description:}

An identity function exists for each of the primitive types. These
functions return thir argument as output, and correspond to the
mathematical function $f(x) = x$. These functions are mostly used in
functional programming constructs, and are used by CX to parse certain
statements like if/else and loops.

\textbf{Examples:}

\begin{lstlisting}
idI32(5)
\end{lstlisting}





\subsection{readBoolA, readByteA, readI32A, readI64A, readF32A, readF64A}

\textbf{Syntax:}

\textbf{readBoolA} []bool i32 $=>$ bool

\textbf{readByteA} []byte i32 $=>$ byte

\textbf{readI32A} []i32 i32 $=>$ i32

\textbf{readI64A} []i64 i32 $=>$ i64

\textbf{readF32A} []f32 i32 $=>$ f32

\textbf{readF64A} []f64 i32 $=>$ f64

\textbf{Description:}

This set of functions are used to retrieve values from arrays of the
corresponding type. The first argument is an array of the required
type, and the second argument is the index of the value to be
retrieved. The output is the value in the array at the indicated
index.

If either a negative index or an index which exceeds the length of the
array minus one (CX arrays are zero-indexed) is provided, an out of
bounds error must be raised.

\textbf{Examples:}

\begin{lstlisting}
readBoolA([]bool{true, false, true}, 0)
addI32(readI32([]i32{0, 1}, 1), 5)
\end{lstlisting}


\begin{scheme}
{\cf addI32}                       {\cf subI32}
{\cf mulI32}                       {\cf divI32}
{\cf addI64}                       {\cf subI64}
{\cf mulI64}                       {\cf divI64}
{\cf addF32}                       {\cf subF32}
{\cf mulF32}                       {\cf divF32}
{\cf addF64}                       {\cf subF64}
{\cf mulF64}                      {\cf divF64}

{\cf printStr}                      {\cf printByte}
{\cf printI32}                     {\cf printI64}
{\cf printF32}                    {\cf printF64}
{\cf printByteA}                 {\cf printI32A}
{\cf printI64A}                  {\cf printF32A}
{\cf printF64A}                  {\cf printBool}

{\cf idStr}                         {\cf idByte}
{\cf idI32}                        {\cf idI64}
{\cf idF32}                       {\cf idF64}
{\cf idByteA}                    {\cf idI32A}
{\cf idI64A}                      {\cf idF32A}
{\cf idF64A}

{\cf readByteA}                 {\cf writeByteA}
{\cf readI32A}                 {\cf writeI32A}
{\cf readI64A}                 {\cf writeI64A}
{\cf readF32A}                 {\cf writeF32A}
{\cf readF64A}                 {\cf writeF64A}

{\cf i64ToI32}                 {\cf f32ToI32}
{\cf f64ToI32}                 {\cf i32ToI64}
{\cf f32ToI64}                 {\cf f64ToI64}

{\cf i32ToF32}                 {\cf i64ToF32}
{\cf f64ToF32}                 {\cf i32ToF64}
{\cf i64ToF64}                 {\cf f32ToF64}
{\cf byteAToStr}

{\cf ltI32}                       {\cf gtI32}
{\cf eqI32}                      {\cf ltI64}
{\cf gtI64}                      {\cf eqI64}

{\cf sleep}
{\cf setClauses}                {\cf addObject}
{\cf setQuery}                   {\cf remObject}
{\cf remExpr}                    {\cf addExpr}
{\cf exprAff}                     {\cf initDef}
{\cf evolve}                       {\cf goTo}

\end{scheme}
