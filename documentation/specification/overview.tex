% 1. Structure of the language

\chapter{Overview of CX}
\label{overview}

\section{Semantics}
\label{semanticsection}

CX is a strongly typed language. %Any aspect of the language's design
%follows the strict guideline
There is no implicit casting in CX, which means that if the programmer
wants to send a 64 bit integer to a function requiring a 32 bit
integer, this argument needs to be explicitly casted to a 64 bit
integer, even if this argument is a literal (e.g., 5 or 10). Because
of this design decision, there are no overloaded functions in CX: if
one wants to calculate the sum of two 32 bit integers, a native
function called ``addI32'' needs to be used. If an argument of
a different type than i32 is sent to ``addI32'', an error is raised.

CX is lexically scoped. Every call to a function is bound to an array
of definitions, called a \textit{state}. Each of these definitions is
defined by a name, a type, and a value. The name is used to uniquely
identify the definition among the other definitions in the state. The
value represents an array of bytes that can be read in a way dictated
by the definition's type.

The primitive types in CX are: boolean, string, byte, 32 bit integer,
64 bit integer, single and double precision floating-point real
numbers, and arrays of these types. As mentioned before, arithmetic
operations among the different primitive types are not permitted, and
an explicit cast must be performed beforehand.

CX must provide the programmer a collection of basic functions (called
``native functions'') that enable the construction of more complex,
user defined functions. These functions are present in a pre-loaded
in a ``core'' module, which is pre-loaded in every CX program.

Any program in CX must have at least two modules: the previously
mentioned core module, and a main module. The main module must have
defined at least one function: the main function, which acts as the
entry point for a CX program.

% explain main module

Every element in a CX program is defined by a group of variables. This
group of variables can be seen as a \textit{struct} in languages like
C or Go. For example, a CX program can be defined as a collection of
modules and a call stack. Next, a module can be defined by a name to
uniquely identify itself among the other modules, a collection of
imported modules, a collection of functions, etc. Each of these
modules are linked to the main program struct, and each of the
functions, structs, etc., defined in a module, is linked to their
corresponding module. This design allows a representation of a CX
program as an abstract syntax tree.

Arguments are always passed to functions by value in CX. For example,
if a 32 bit integer array is sent to the native function ``writeI32A''
to change one of the values of the array, a new array is created with
the altered value.

In CX, a variable or constant that is created outside of any function
is called a definition. Definitions have global scope, which means
that any function in the current module or in modules which import the
current module have access to it. Definitions can be declared of any
of the primitive types or user-defined types.

User-defined types are created using CX structs. A struct, as in
other languages such as C or Go, are a group of variables that
are collectively identified by a name.

%\section{Syntax}
% There's no syntax is CX

\section{CX REPL}
\label{cx-repl}

CX is both a compiled and interpreted language. In its interpreted
form, CX provides the programmer a REPL (read, eval, print loop),
where programs can be constructed and executed interactively. The
programmer can append new CX elements by entering functions,
expressions, definitions, etc., as in writing a program in a source
code file, and can also use meta-programming commands that can
manipulate a program's structure and execution.

\section{Identifiers}
\label{identifiers}

\subsection{Base and }
\label{qualifiers}

\subsection{Error situations and unspecified behavior}
\label{errorsituations}

\subsection{Entry format}

% \noindent%
% \pproto{(make-vector \var{k})}{procedure}
% \pproto{(make-vector \var{k} \var{fill})}{procedure}\unpenalty


% \newcommand{\foo}[1]{\vr{#1}, \vri{#1}, $\ldots$ \vrj{#1}, $\ldots$}
% $$
% \begin{tabular}{ll}
% \vr{alist}&association list (list of pairs)\\
% \vr{boolean}&boolean value (\schtrue{} or \schfalse{})\\
% \vr{byte}&exact integer $0 \leq byte < 256$\\
% \vr{bytevector}&bytevector\\
% \vr{char}&character\\
% \vr{end}&exact non-negative integer\\
% \foo{k}&exact non-negative integer\\
% \vr{letter}&alphabetic character\\
% \foo{list}&list (see section~\ref{listsection})\\
% \foo{n}&integer\\
% \var{obj}&any object\\
% \vr{pair}&pair\\
% \vr{port}&port\\
% \vr{proc}&procedure\\
% \foo{q}&rational number\\
% \vr{start}&exact non-negative integer\\
% \vr{string}&string\\
% \vr{symbol}&symbol\\
% \vr{thunk}&zero-argument procedure\\
% \vr{vector}&vector\\
% \foo{x}&real number\\
% \foo{y}&real number\\
% \foo{z}&complex number\\
% \end{tabular}
% $$


% \begin{itemize}

% \item{It is an error if \var{start} is greater than \var{end}.}

% \item{It is an error if \var{end} is greater than the length of the
% string, vector, or bytevector.}

% \item{If \var{start} is omitted, it is assumed to be zero.}

% \item{If \var{end} is omitted, it assumed to be the length of the string,
% vector, or bytevector.}

% \item{The index \var{start} is always inclusive and the index \var{end} is always
% exclusive.  As an example, consider a string.  If
% \var{start} and \var{end} are the same, an empty
% substring is referred to, and if \var{start} is zero and \var{end} is
% the length of \var{string}, then the entire string is referred to.}

% \end{itemize}

\subsection{Evaluation examples}

% \begin{scheme}
% (* 5 8)      \ev  40%
% \end{scheme}

\subsection{Naming conventions}
