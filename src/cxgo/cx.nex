/(\r\n|\r|\n)/ {
	lval.line++
}
/(\t| )/ {
	/* skip blanks and tabs */
}
/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|\/\/[^\n\r]*/ {
	/* skip comments */
	lval.line = lval.line + countNewLines([]byte(yylex.Text()))
}
/:clauses/   { return CCLAUSES   }
/:objects/   { return COBJECTS   }
/:object/    { return COBJECT    }
/:query/     { return QUERY      }
/:dQuery/    { return DQUERY     }
/:dState/    { return DSTATE     }
/:dStack/    { return DSTACK     }
/:dProgram/  { return DPROGRAM   }
/:package/   { return SPACKAGE   }
/:struct/    { return SSTRUCT    }
/:func/      { return SFUNC      }
/:rem/       { return REM        }
/:step/      { return STEP       }
/:tStep/     { return TSTEP      }
/:pStep/     { return PSTEP      }
/:aff/       { return AFF        }
/package/    { return PACKAGE    }
/type/       { return TYPSTRUCT  }
/struct/     { return STRUCT     }
/return/     { return RETURN     }
/goto/       { return GOTO       }
/if/         { return IF         }
/else/       { return ELSE       }
/for/        { return FOR        }
/,/          { return COMMA      }
/func/       { return FUNC       }
/clauses/    { return CLAUSES    }
/objects/    { return OBJECTS    }
/object/     { return OBJECT     }
/expr/       { return EXPR       }
/def/        { return DEF        }
/field/      { return FIELD      }
/input/      { return INPUT      }
/output/     { return OUTPUT     }
/import/     { return IMPORT     }
/var/        { return VAR        }
/\(/         { return LPAREN     }
/\)/         { return RPAREN     }
/\{/         { return LBRACE     }
/\}/         { return RBRACE     }
/=/          { return ASSIGN     }
/:=/         { return CASSIGN    }
/>/          { return GTHAN      }
/</          { return LTHAN      }
/<=/         { return LTEQ       }
/>=/         { return GTEQ       }
/(str|bool|byte|i32|i64|f32|f64|\[\]bool|\[\]byte|\[\]i32|\[\]i64|\[\]f32|\[\]f64)(\.(\[\])?[a-zA-Z0-9_]+)/ {
	lval.tok = yylex.Text()
	return IDENT
}
/bool/       { lval.tok = yylex.Text(); return BOOL     }
/str/        { lval.tok = yylex.Text(); return STR      }
/i32/        { lval.tok = yylex.Text(); return I32      }
/i64/        { lval.tok = yylex.Text(); return I64      }
/f32/        { lval.tok = yylex.Text(); return F32      }
/f64/        { lval.tok = yylex.Text(); return F64      }
/byte/       { lval.tok = yylex.Text(); return BYTE     }
/\[\]bool/   { lval.tok = yylex.Text(); return BOOLA    }
/\[\]byte/   { lval.tok = yylex.Text(); return BYTEA    }
/\[\]i32/    { lval.tok = yylex.Text(); return I32A     }
/\[\]i64/    { lval.tok = yylex.Text(); return I64A     }
/\[\]f32/    { lval.tok = yylex.Text(); return F32A     }
/\[\]f64/    { lval.tok = yylex.Text(); return F64A     }
/"([^"]*)"/ { /* " */
	lval.tok = yylex.Text()
	lval.line = lval.line + countNewLines([]byte(lval.tok))
	return STRING
}
/true/ {
	lval.i32 = int32(1)
	return BOOLEAN
}
/false/ {
	lval.i32 = int32(0)
	return BOOLEAN
}
/-?[0-9]+/ {
	result ,_ := strconv.Atoi(yylex.Text())
	lval.i32 = int32(result)
	return INT
}
/-?[0-9]+\.[0-9]*/ {
	result ,_ := strconv.ParseFloat(yylex.Text(), 32)
	lval.f32 = float32(result)
	return FLOAT
}
/[_a-zA-Z][a-zA-Z0-9_]*:/ {
	lval.tok = yylex.Text()
	return TAG
}
/[_a-zA-Z][a-zA-Z0-9_]*(\.[a-zA-Z0-9_]+)?/ {
	lval.tok = yylex.Text()
	return IDENT
}
/;/ { return int(yylex.Text()[0]) }
//
package main
import (
	"os"
	"os/exec"
	"fmt"
	"bytes"
	"time"
	"io/ioutil"
	"strconv"
	"encoding/json"

//	"flag"

	"net"
	"net/http"
	
	"runtime"

	//"github.com/skycoin/viscript/signal"
	
	"github.com/skycoin/skycoin/src/cipher/encoder"
	. "github.com/skycoin/cx/src/base"
)

func countNewLines (s []byte) int {
	count := 0
	for i := 0; i < len(s); i++ {
		if s[i] == '\n' {
			count++
		}
	}
	return count
}

func readline (fi *bufio.Reader) (string, bool) {
	s, err := fi.ReadString(';')
	if err != nil {
		return "", false
	}
	return s, true
}

func repl () {
	fmt.Println("CX REPL")
	fmt.Println("More information about CX is available at http://cx.skycoin.net/")

	inREPL = true

	fi := bufio.NewReader(os.NewFile(0, "stdin"))

	for {
		var inp string
		var ok bool

		fmt.Println()

		if replTargetMod != "" {
			fmt.Println(fmt.Sprintf(":package %s {...", replTargetMod))
			fmt.Printf("\t* ")
		} else if replTargetFn != "" {
			fmt.Println(fmt.Sprintf(":func %s {...", replTargetFn))
			fmt.Printf("\t* ")
		} else if replTargetStrct != "" {
			fmt.Println(fmt.Sprintf(":struct %s {...", replTargetStrct))
			fmt.Printf("\t* ")
		} else {
			fmt.Printf("* ")
		}
		
		if inp, ok = readline(fi); ok {
			if replTargetFn != "" {
				inp = fmt.Sprintf(":func %s {%s}", replTargetFn, inp)
			}
			if replTargetMod != "" {
				inp = fmt.Sprintf(":package %s {%s}", replTargetMod, inp)
			}
			if replTargetStrct != "" {
				inp = fmt.Sprintf(":struct %s {%s}", replTargetStrct, inp)
			}
			b := bytes.NewBufferString(inp)
			yyParse(NewLexer(b))
		} else {
			if replTargetFn != "" {
				replTargetFn = ""
				fmt.Println()
				continue
			}

			if replTargetStrct != "" {
				replTargetStrct = ""
				fmt.Println()
				continue
			}

			if replTargetMod != "" {
				replTargetMod = ""
				fmt.Println()
				continue
			}

			fmt.Printf("\nBye!\n")
			break
		}
	}
}

var coreModule string = `
package core
func str.id (x str) (x str) {}
func bool.id (x bool) (x bool) {}
func byte.id (x byte) (x byte) {}
func i32.id (x i32) (x i32) {}
func i64.id (x i64) (x i64) {}
func f32.id (x f32) (x f32) {}
func f64.id (x f64) (x f64) {}
func []bool.id (x []bool) (x []bool) {}
func []byte.id (x []byte) (x []byte) {}
func []i32.id (x []i32) (x []i32) {}
func []i64.id (x []i64) (x []i64) {}
func []f32.id (x []f32) (x []f32) {}
func []f64.id (x []f64) (x []f64) {}

func i32.add (n1 i32, n2 i32) (out i32) {}
func i32.sub (n1 i32, n2 i32) (out i32) {}
func i32.mul (n1 i32, n2 i32) (out i32) {}
func i32.div (n1 i32, n2 i32) (out i32) {}

func i64.add (n1 i64, n2 i64) (out i64) {}
func i64.sub (n1 i64, n2 i64) (out i64) {}
func i64.mul (n1 i64, n2 i64) (out i64) {}
func i64.div (n1 i64, n2 i64) (out i64) {}

func f32.add (n1 f32, n2 f32) (out f32) {}
func f32.sub (n1 f32, n2 f32) (out f32) {}
func f32.mul (n1 f32, n2 f32) (out f32) {}
func f32.div (n1 f32, n2 f32) (out f32) {}

func f64.add (n1 f64, n2 f64) (out f64) {}
func f64.sub (n1 f64, n2 f64) (out f64) {}
func f64.mul (n1 f64, n2 f64) (out f64) {}
func f64.div (n1 f64, n2 f64) (out f64) {}

func i32.mod (n1 i32, n2 i32) (rem i32) {}
func i64.mod (n1 i64, n2 i64) (rem i64) {}

func i32.and (n1 i32, n2 i32) (out i32) {}
func i32.or (n1 i32, n2 i32) (out i32) {}
func i32.xor (n1 i32, n2 i32) (out i32) {}
func i32.andNot (n1 i32, n2 i32) (out i32) {}

func i64.and (n1 i64, n2 i64) (out i64) {}
func i64.or (n1 i64, n2 i64) (out i64) {}
func i64.xor (n1 i64, n2 i64) (out i64) {}
func i64.andNot (n1 i64, n2 i64) (out i64) {}

func and (c1 bool, c2 bool) (out bool) {}
func or (c1 bool, c2 bool) (out bool) {}
func not (c1 bool) (out bool) {}

func i32.lt (n1 i32, n2 i32) (out bool) {}
func i32.gt (n1 i32, n2 i32) (out bool) {}
func i32.eq (n1 i32, n2 i32) (out bool) {}
func i32.lteq (n1 i32, n2 i32) (out bool) {}
func i32.gteq (n1 i32, n2 i32) (out bool) {}

func i64.lt (n1 i64, n2 i64) (out bool) {}
func i64.gt (n1 i64, n2 i64) (out bool) {}
func i64.eq (n1 i64, n2 i64) (out bool) {}
func i64.lteq (n1 i64, n2 i64) (out bool) {}
func i64.gteq (n1 i64, n2 i64) (out bool) {}

func f32.lt (n1 f32, n2 f32) (out bool) {}
func f32.gt (n1 f32, n2 f32) (out bool) {}
func f32.eq (n1 f32, n2 f32) (out bool) {}
func f32.lteq (n1 f32, n2 f32) (out bool) {}
func f32.gteq (n1 f32, n2 f32) (out bool) {}

func f64.lt (n1 f64, n2 f64) (out bool) {}
func f64.gt (n1 f64, n2 f64) (out bool) {}
func f64.eq (n1 f64, n2 f64) (out bool) {}
func f64.lteq (n1 f64, n2 f64) (out bool) {}
func f64.gteq (n1 f64, n2 f64) (out bool) {}

func str.lt (n1 str, n2 str) (out bool) {}
func str.gt (n1 str, n2 str) (out bool) {}
func str.eq (n1 str, n2 str) (out bool) {}
func str.lteq (n1 str, n2 str) (out bool) {}
func str.gteq (n1 str, n2 str) (out bool) {}

func byte.lt (n1 byte, n2 byte) (out bool) {}
func byte.gt (n1 byte, n2 byte) (out bool) {}
func byte.eq (n1 byte, n2 byte) (out bool) {}
func byte.lteq (n1 byte, n2 byte) (out bool) {}
func byte.gteq (n1 byte, n2 byte) (out bool) {}

func []byte.str (in []byte) (out str) {}
func str.[]byte (in str) (out []byte) {}

func i32.byte (in i32) (out byte) {}
func i64.byte (in i64) (out byte) {}
func f32.byte (in f32) (out byte) {}
func f64.byte (in f64) (out byte) {}

func byte.i32 (in byte) (out i32) {}
func i64.i32 (in i64) (out i32) {}
func f32.i32 (in f32) (out i32) {}
func f64.i32 (in f64) (out i32) {}

func byte.i64 (in byte) (out i64) {}
func i32.i64 (in i32) (out i64) {}
func f32.i64 (in f32) (out i64) {}
func f64.i64 (in f64) (out i64) {}

func byte.f32 (in byte) (out f32) {}
func i32.f32 (in i32) (out f32) {}
func i64.f32 (in i64) (out f32) {}
func f64.f32 (in f64) (out f32) {}

func byte.f64 (in byte) (out f64) {}
func i32.f64 (in i32) (out f64) {}
func i64.f64 (in i64) (out f64) {}
func f32.f64 (in f32) (out f64) {}

func []i32.[]byte (in []i32) (out []byte) {}
func []i64.[]byte (in []i64) (out []byte) {}
func []f32.[]byte (in []f32) (out []byte) {}
func []f64.[]byte (in []f64) (out []byte) {}

func []byte.[]i32 (in []byte) (out []i32) {}
func []i64.[]i32 (in []i64) (out []i32) {}
func []f32.[]i32 (in []f32) (out []i32) {}
func []f64.[]i32 (in []f64) (out []i32) {}

func []byte.[]i64 (in []byte) (out []i64) {}
func []i32.[]i64 (in []i32) (out []i64) {}
func []f32.[]i64 (in []f32) (out []i64) {}
func []f64.[]i64 (in []f64) (out []i64) {}

func []byte.[]f32 (in []byte) (out []f32) {}
func []i32.[]f32 (in []i32) (out []f32) {}
func []i64.[]f32 (in []i64) (out []f32) {}
func []f64.[]f32 (in []f64) (out []f32) {}

func []byte.[]f64 (in []byte) (out []f64) {}
func []i32.[]f64 (in []i32) (out []f64) {}
func []i64.[]f64 (in []i64) (out []f64) {}
func []f32.[]f64 (in []f32) (out []f64) {}

func baseGoTo (predicate bool, thenLines i32, elseLines i32) () {}
func goTo (label str) () {}

func bool.print (p bool) () {}
func str.print (s str) () {}
func byte.print (n byte) () {}
func i32.print (n i32) () {}
func i64.print (n i64) () {}
func f32.print (n f32) () {}
func f64.print (n f64) () {}
func []bool.print (n []bool) () {}
func []byte.print (n []byte) () {}
func []i32.print (n []i32) () {}
func []i64.print (n []i64) () {}
func []f32.print (n []f32) () {}
func []f64.print (n []f64) () {}

func []bool.make (size i32) (arr []bool) {}
func []byte.make (size i32) (arr []byte) {}
func []i32.make (size i32) (arr []i32) {}
func []i64.make (size i32) (arr []i64) {}
func []f32.make (size i32) (arr []f32) {}
func []f64.make (size i32) (arr []f64) {}

func []bool.read (arr []bool, idx i32) (lit bool) {}
func []bool.write (arr []bool, idx i32, val bool) (arr []bool) {}
func []byte.read (arr []byte, idx i32) (lit byte) {}
func []byte.write (arr []byte, idx i32, val byte) (arr []byte) {}
func []i32.read (arr []i32, idx i32) (lit i32) {}
func []i32.write (arr []i32, idx i32, val i32) (arr []i32) {}
func []i64.read (arr []i64, idx i32) (lit i64) {}
func []i64.write (arr []i64, idx i32, val i64) (arr []i64) {}
func []f32.read (arr []f32, idx i32) (lit f32) {}
func []f32.write (arr []f32, idx i32, val f32) (arr []f32) {}
func []f64.read (arr []f64, idx i32) (lit f64) {}
func []f64.write (arr []f64, idx i32, val f64) (arr []f64) {}

func []bool.len (arr []bool) (len i32) {}
func []byte.len (arr []byte) (len i32) {}
func []i32.len (arr []i32) (len i32) {}
func []i64.len (arr []i64) (len i32) {}
func []f32.len (arr []f32) (len i32) {}
func []f64.len (arr []f64) (len i32) {}

func sleep (ms i32) () {}

func i32.rand (min i32, max i32) (r i32) {}
func i64.rand (min i64, max i64) (r i64) {}

func setClauses (clss str) () {}
func setQuery (qry str) () {}
func addObject (obj str) () {}
func remObject (obj str) () {}
func remObjects () () {}

func remExpr (tag str) () {}
func remArg (tag str) () {}
func addExpr (tag str, fnName str) () {}
func affExpr (tag str, filter str, index i32) (numAffs i32) {}

func evolve (fnName str, fnBag str, inps []f64, outs []f64, numberExprs i32, iterations i32, epsilon f64) (success f64) {}
func serialize () (sPrgrm []byte) {}
func deserialize (sPrgrm []byte) (err bool) {}

func initDef (typ str) (typ str) {}

func halt (msg str) (out bool) {}
`

func unsafeEval (code string) (out string) {
	var lexer *Lexer
	defer func() {
		if r := recover(); r != nil {
			out = fmt.Sprintf("%v", r)
			lexer.Stop()
		}
	}()
	
	// storing strings sent to standard output
	old := os.Stdout
	r, w, _ := os.Pipe()
	os.Stdout = w
	
	lineNo = 0
	
	b := bytes.NewBufferString(coreModule)
	lexer = NewLexer(b)
	yyParse(lexer)
	
	b = bytes.NewBufferString(code)
	lexer = NewLexer(b)
	yyParse(lexer)

	if err := cxt.Run(false, -1); err != nil {
		cxt = MakeContext()
		return fmt.Sprintf("%s", err)
	}

	if len(cxt.Outputs) > 0 {
		outVal := *cxt.Outputs[0].Value
	
		switch cxt.Outputs[0].Typ {
		case "bool":
			var out bool
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		case "str":
			fmt.Println(string(outVal))
		case "byte":
			fmt.Println(outVal)
		case "i32":
			var out int32
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		case "i64":
			var out int64
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		case "f32":
			var out float32
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		case "f64":
			var out float64
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		case "[]bool":
			var out []bool
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		case "[]byte":
			var out []byte
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		case "[]i32":
			var out []int32
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		case "[]i64":
			var out []int64
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		case "[]f32":
			var out []float32
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		case "[]f64":
			var out []float64
			encoder.DeserializeRaw(outVal, &out)
			fmt.Println(out)
		default:
			
		}
	}
	

	outC := make(chan string)
	go func() {
		var buf bytes.Buffer
		io.Copy(&buf, r)
		outC <- buf.String()
	}()
	
	w.Close()
	os.Stdout = old // restoring the real stdout
	out = <-outC

	cxt = MakeContext()
	return out
}

func Eval (code string) string {
	runtime.GOMAXPROCS(2)
	ch := make(chan string, 1)

	var result string
	
	go func() {
		result = unsafeEval(code)
		ch <- result
	}()

	timer := time.NewTimer(20 * time.Second)
	defer timer.Stop()

	select {
	case <-ch:
		return result
	case <-timer.C:
		cxt = MakeContext()
		return "Timed out."
	}
}

type SourceCode struct {
	Code string
}

func WebMode () {
	host := ":5336"

	mux := http.NewServeMux()
	
	mux.Handle("/", http.FileServer(http.Dir("./dist")))
	
	mux.HandleFunc("/eval", func(w http.ResponseWriter, r *http.Request) {
		defer r.Body.Close()
		var b []byte
		var err error
		if b, err = ioutil.ReadAll(r.Body); err != nil {
			http.Error(w, err.Error(), 500)
			return
		}
		
		var source SourceCode
		if err := json.Unmarshal(b, &source); err != nil {
			http.Error(w, err.Error(), 500)
			return
		}

		if err := r.ParseForm(); err == nil {
			fmt.Fprintf(w, "%s", Eval(source.Code))
		}
	})

	if listener, err := net.Listen("tcp", host); err == nil {
		fmt.Println("Starting CX web service on http://127.0.0.1:5336/")
		http.Serve(listener, mux)
	}
}

func parseFile (fileName string) {
	sourceCode, err := os.Open(fileName)
	if err != nil {
		panic(fmt.Sprintf("Couldn't read file."))
	}
	yyParse(NewLexer(sourceCode))
}

func help () {
	fmt.Printf(`Usage: cx [options] [source-files]

CX options:
-b, --base                        Generate a "out.cx.go" file with the transcompiled CX Base source code.
-c, --compile                     Generate a "out" executable file of the program.
-co, --compile-output FILENAME    Specifies the filename for the generated executable.
-h, --help                        Prints this message.
-r, --repl                        Loads source files into memory and starts a read-eval-print loop.
-w, --web                         Start CX as a web service.

Signal options:
-signal-client                   Run signal client
-signal-client-id UINT           Id of signal client (default 1)
-signal-server-address STRING    Address of signal server (default "localhost:7999")

Notes:
* Options --compile and --repl are mutually exclusive.
* Option --web makes every other flag to be ignored.
`)
}

func (yylex Lexer) Error (e string) {
	if inREPL {
		fmt.Printf("syntax error: %s\n", e)
	} else {
		fmt.Printf("%d: syntax error: %s\n", yylex.Line() + 1, e)
	}
	
	yylex.Stop()
}

// var memprofile = flag.String("memprofile", "", "write memory profile to `file`")

func main () {

	//TestGl()
	runtime.GOMAXPROCS(2)

	//signal.Listen("0.0.0.0:7999")

	args := os.Args[1:]
	var sourceCode []*os.File

	if len(args) == 0 {
		replMode = true
	}

	flagMode := false
	var compileOutput string = "o"
	for i, arg := range args {
		if arg == "--web" || arg == "-w" {
			webMode = true
			flagMode = true
			continue
		}
		if arg == "--repl" || arg == "-r" {
			replMode = true
			flagMode = true
			continue
		}
		if arg == "--base" || arg == "-b" {
			baseOutput = true
			flagMode = true
			continue
		}
		if arg == "--compile" || arg == "-c" {
			compileMode = true
			baseOutput = true
			flagMode = true
			continue
		}
		if arg == "--compile-output" || arg == "-co" {
			compileOutput = args[i+1]
			continue
		}
		if arg == "--help" || arg == "-h" {
			helpMode = true
			flagMode = true
			continue
		}
		// viscript options
		if arg == "-signal-client" || arg == "-signal-client-id" || arg == "-signal-server-address" {
			continue
		}
		if i > 0 && (args[i-1] == "-signal-client-id" || args[i-1] == "-signal-server-address") {
			continue
		}
		if !flagMode {
			file, err := os.Open(arg)
			if err != nil {
				panic(fmt.Sprintf("Couldn't read file."))
			}
			sourceCode = append(sourceCode, file)
		}
	}

	if helpMode {
		help()
		return
	}

	if webMode {
		WebMode()
		return
	}

	if compileMode && replMode {
		fmt.Println("Error: Options --compile and --repl are mutually exclusive.")
		return
	}

	if baseOutput {
		program.WriteString(`package main;import (. "github.com/skycoin/cx/src/base";);var cxt = MakeContext();var mod *CXModule;var imp *CXModule;var fn *CXFunction;var op *CXFunction;var expr *CXExpression;var goToExpr *CXExpression;var strct *CXStruct;var arg *CXArgument;var tag string = "";func main () {`)
	}

	// adding core module and native functions to it
	b := bytes.NewBufferString(coreModule)
	yyParse(NewLexer(b))

	// parsing all source code files
	for _, source := range sourceCode {
		yyParse(NewLexer(source))
	}
	
	// if sourceCode != nil {
	// 	yyParse(NewLexer(sourceCode))
	// }
	
	lineNo = 0

	if replMode || len(sourceCode) == 0 {
		repl()
	} else if !compileMode && !baseOutput && len(sourceCode) > 0 {
		if err := cxt.Run(false, -1); err != nil {
			fmt.Println(err)
			repl()
		}
	}
	
	if baseOutput {
		program.WriteString(`cxt.Run(false, -1);}`)
		ioutil.WriteFile(fmt.Sprintf("%s.go", compileOutput), []byte(program.String()), 0644)
		cxt.Compile(true)
	}
	if compileMode {
		baseFilename := fmt.Sprintf("%s.go", compileOutput)
		build := exec.Command("go", "build", baseFilename)
		build.Run()
		removeBase := exec.Command("rm", baseFilename)
		removeBase.Run()
	}
}
