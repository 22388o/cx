package Math

var PI f32 = 3.14159

func Square (num f32) (out f32) {
	mulF32(num, num)
}

package Stat

func Mean (vals []f32) (mean f32) {
	if eqI32(lenF32A(vals), 0) {
		printStr("error?")
		halt("Stat.Mean: division by 0")
	}
	var sum f32 = 0.0
	var counter i32 = 0
	for ltI32(counter, lenF32A(vals)) {
		sum = addF32(sum, readF32A(vals, counter))
		counter = addI32(counter, 1)
	}
	mean = divF32(sum, i32ToF32(lenF32A(vals)))
}

func Variance (vals []f32) (variance f32) {
	mean := Mean(vals)
	var sum f32 = 0.0
	var counter i32 = 0
	for ltI32(counter, lenF32A(vals)) {
		sum = Math.Square(subF32(readF32A(vals, counter), mean))
		counter = addI32(counter, 1)
	}
	variance = divF32(sum, i32ToF32(lenF32A(vals)))
}

package main
import "Math"

var greeting str = "hello"
var ten i32 = 10
var five i32 = 5
// var foo i32 = 10
// var bar f64 = 4.17
// var par i32 = 30
// var boo i32 = 40
// var epsilon f64 = 1.531
var boolArr []bool = []bool{true, true, true, false, false}
var inps []f32 = []f32{
	-10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0,
	0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0}
var outs []f32 = []f32{
	-970.0, -702.0, -488.0, -322.0, -198.0, -110.0, -52.0, -18.0, -2.0,
	2.0, 0.0, -2.0, 2.0, 18.0, 52.0, 110.0, 198.0, 322.0, 488.0, 702.0, 970.0}

type Shape struct {
	perimeter f32
	area f32
}

type Point struct {
	name str
	x i32
	y i32
}

var myPoint Point
var myInt i32

func double (num f32) (out f32) {
	out := addF32(num, num)
}

func quad (num f32) (out f32) {
	out := double(num)
}

func voidFn () () {
}

func solution (n f64) (out f64) {
	double = addF64(n, n)
	triple = addF64(double, n)
	square = mulF64(n, n)
	cubic = mulF64(square, n)
	out = subF64(cubic, triple)
}

var goNorth str = "going north."
var goSouth str = "going south."
var goWest str = "going west."
var goEast str = "going east."

//:func voidFn

var bytes []byte = []byte{11, 22, 33}

/*
  Function for robot simulator
*/

func robotAct (row i32, col i32, action str) (row i32, col i32) {
	printStr(action)
	if eqStr(action, "going north.") {
		row = addI32(row, -1)
		//col = col
	}
	if eqStr(action, "going south.") {
		row = addI32(row, 1)
		//col = col
	}
	if eqStr(action, "going east.") {
		//row = row
		col = addI32(col, 1)
	}
	if eqStr(action, "going west.") {
		//row = row
		col = addI32(col, -1)
	}
}

func robot (row i32, col i32) (row i32, col i32) {
	remArg("robot")
	exprAff("goNorth|goSouth|goWest|goEast")
	row, col = robotAct(row, col, "")
}

func changeValue (num i32) (num i32) {
	num = addI32(num, 10)
}

func map2Dto1D (r i32, c i32, w i32) (i i32) {
	i = addI32(mulI32(w, r), c)
}

func map1Dto2D (i i32, w i32) (r i32, c i32) {
	r = divI32(i, W)
	c = modI32(i, W)
}

func robotObjects (row i32, col i32, width i32, wallMap []bool, wormholeMap []bool) () {
	remObjects()
	if readBoolA(wallMap, map2Dto1D(addI32(row, -1), col, width)) {
		addObject("northWall")
	}
	if readBoolA(wallMap, map2Dto1D(addI32(row, 1), col, width)) {
		addObject("southWall")
	}
	if readBoolA(wallMap, map2Dto1D(row, addI32(col, 1), width)) {
		addObject("eastWall")
	}
	if readBoolA(wallMap, map2Dto1D(row, addI32(col, -1), width)) {
		addObject("westWall")
	}

	if readBoolA(wormholeMap, map2Dto1D(addI32(row, -1), col, width)) {
		addObject("northWormhole")
	}
	if readBoolA(wormholeMap, map2Dto1D(addI32(row, 1), col, width)) {
		addObject("southWormhole")
	}
	if readBoolA(wormholeMap, map2Dto1D(row, addI32(col, 1), width)) {
		addObject("eastWormhole")
	}
	if readBoolA(wormholeMap, map2Dto1D(row, addI32(col, -1), width)) {
		addObject("westWormhole")
	}
}

var foo []f32 = []f32{3.3, 5.3}
var bar []byte = []byte{0, 1000, 2}

func main () (outMain f32) {
	:dStack false;
	var outMain f32 = 3.14
	//printF32(Math.PI)
	//printF32(Math.square(7.5))
	printStr(greeting)
	printF32(Stat.Mean(foo))
	printF32(Stat.Variance(foo))
	
	printByteA(bar)

	
	printI32A(byteAToI32A([]byte{1, 2, 3, 4}))

	printStr(byteAToStr([]byte{65, 66, 67}))
	printByteA(strToByteA("ABC"))
	
	printByte(i32ToByte(50))
	printByte(i64ToByte(i32ToI64(50)))
	printByte(f32ToByte(50.5))
	printByte(f64ToByte(f32ToF64(50.5)))

	:tag huehue;
	
	printByteA(i32AToByteA([]i32{50, 60, 70, 80}))
	printByteA(i64AToByteA([]i64{55, 65, 75, 85}))
	printByteA(f32AToByteA([]f32{50.5, 60.5, 70.5, 80.5}))
	printByteA(f64AToByteA([]f64{55.5, 65.5, 75.5, 85.5}))

	// var counter i32 = 0
	// for ltI32(counter, 1) {
	// 	//printI32(counter)
	// 	counter = addI32(counter, 1)
	// }
}

//./cx.sh && ./cx --load src/cxgo/test.cx 
