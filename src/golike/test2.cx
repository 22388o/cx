package main


//var greeting str = "hello"
//var true byte = 1
//var false byte = 0
var ten i32 = 10
var five i32 = 5
var foo i32 = 10
var bar f64 = 4.17
//var par i32 = 30
//var boo i32 = 40
var epsilon f64 = 1.531
var inps []f64 = []f64{
	-10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0,
	0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0}
var outs []f64 = []f64{
	-970.0, -702.0, -488.0, -322.0, -198.0, -110.0, -52.0, -18.0, -2.0,
	2.0, 0.0, -2.0, 2.0, 18.0, 52.0, 110.0, 198.0, 322.0, 488.0, 702.0, 970.0}

type Point struct {
	name str,
	x i32,
	y i32
}

var myPoint struct Point

/*
  Native functions
*/

func idByte (x byte) (x byte) {}
func idI32 (x i32) (x i32) {}
func idI64 (x i64) (x i64) {}
func idF32 (x f32) (x f32) {}
func idF64 (x f64) (x f64) {}
func idByteA (x []byte) (x []byte) {}
func idI32A (x []i32) (x []i32) {}
func idI64A (x []i64) (x []i64) {}
func idF32A (x []f32) (x []f32) {}
func idF64A (x []f64) (x []f64) {}

func addI32 (n1 i32, n2 i32) (out i32) {}
func subI32 (n1 i32, n2 i32) (out i32) {}
func mulI32 (n1 i32, n2 i32) (out i32) {}
func divI32 (n1 i32, n2 i32) (out i32) {}

func addI64 (n1 i64, n2 i64) (out i64) {}
func subI64 (n1 i64, n2 i64) (out i64) {}
func mulI64 (n1 i64, n2 i64) (out i64) {}
func divI64 (n1 i64, n2 i64) (out i64) {}

func addF64 (n1 f64, n2 f64) (out f64) {}
func subF64 (n1 f64, n2 f64) (out f64) {}
func mulF64 (n1 f64, n2 f64) (out f64) {}
func divF64 (n1 f64, n2 f64) (out f64) {}

func ltI32 (n1 i32, n2 i32) (out byte) {}
func gtI32 (n1 i32, n2 i32) (out byte) {}
func eqI32 (n1 i32, n2 i32) (out byte) {}

func ltI64 (n1 i64, n2 i64) (out byte) {}
func gtI64 (n1 i64, n2 i64) (out byte) {}
func eqI64 (n1 i64, n2 i64) (out byte) {}

func byteAtoStr (in []byte) (out str) {}
func i32toI64 (in i32) (out i64) {}
func f32toI64 (in f32) (out i64) {}
func f64toI64 (in f64) (out i64) {}

func goTo (predicate byte, thenLine i32, elseLine i32) (out byte) {}

func printStr (s str) (s str) {}
func printByte (n byte) (out byte) {}
func printI32 (n i32) (out i32) {}
func printI64 (n i64) (out i64) {}
func printF32 (n f64) (out f32) {}
func printF64 (n f64) (out f64) {}
func printByteA (n []byte) (out []byte) {}
func printI32A (n []i32) (out []i32) {}
func printI64A (n []i64) (out []i64) {}
func printF32A (n []f64) (out []f32) {}
func printF64A (n []f64) (out []f64) {}

// func readAByte (arr []byte, idx i32) (byt byte) {}
// func writeAByte (arr []byte, idx i32, val byte) (byt byte) {}

func evolve (fnName str, fnBag str, inps []f64, outs []f64, numberExprs i32, iterations i32, epsilon f64) (success f64) {}

func initDef (typ str) (typ str) {}


/*
  Actual program
*/

func double (num f64) (out f64) {
	//out = addF64(num, num)
}

func voidFn () () {
	//print(bar)
}

func solution (n f64) (out f64) {
	// double = addF64(n, n)
	// triple = addF64(double, n)
	// square = mulF64(n, n)
	// cubic = mulF64(square, n)
	// out = subF64(cubic, triple)
}

func main () (outMain f64) {
	outMain := divF64(3.0, 7.0)

	// true := gtI32(ten, five)
	// false := gtI32(five, ten)




	//num := addI32(3, 3)


	
	pred := gtI64(5, 10)
	if pred {
		result := addI64(7, 10)
		//print(25)
	} else {
		result := addI64(20, 3)
	}


	// i := idI32(0)
	// pred := ltI32(i, 10)
	// while pred {
	// 	print(i)
	// 	i := addI32(i, 1)
	// 	i := addI32(i, 1)
	// 	i := addI32(i, 1)
	// 	pred := ltI32(i, 10)
	// }

	//print(result)

	var myPoint struct Point
	
	var i i64 = 0
	pred := ltI64(i, 10000)
	while pred {
		printI64(i)
		i := addI64(i, 1)
		pred := ltI64(i, 10000)
	}

	printI32(myPoint.x)

	//var bar f64 = 4.17
	// casting
	foo1 := f64toI64(bar)
	foo2 := addI64(foo1, foo1)
	printI64(foo1)
	printF64A(inps)

	printStr("hello")
}
