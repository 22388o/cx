package main
import "testing"
import "issues"
import "time"

func main () {
	printf("\nRunning CX core tests\n")
	
	var start i64
	start = time.UnixNano()
	
	testing.testI32()
	testing.testI64()
	testing.testF32()
	testing.testF64()
	testing.testBOOL()
	testing.testArray()
	testing.testFunctions()

	testing.testControlFlow()
	testing.testStructures()

	testing.testSTR()
	testing.testPointers()
	testing.testSlices()
	testing.testShortDeclarations()
	testing.testParse()
	testing.collectionFunctions()

	var end i64
	end = time.UnixNano()

	// counting successful tests
	var successfulTests i32
	for c := 0; c < len(res); c++ {
		if res[c] {
			successfulTests = successfulTests + 1
		}
	}
	
	printf("Tests finished after %d nanoseconds (%f milliseconds)\n\n", i64.sub(end, start), f64.div(i64.f64(end-start), 1000000.0D))
	printf("A total of %d tests were performed\n", len(res))
	printf("%d were successful\n", successfulTests)
	printf("%d failed\n", len(res) - successfulTests)



	issues.testIssues()











	// printf("\nRunning CX issues tests\n")
	
	// var startIssues i64
	// startIssues = time.UnixNano()
	
	// // Issue 18: String not working across packages
	// issues.issue18()
	// // Issue 19: Order of files matters for structs
	// // We just compile the files in issue-19/
	// // Issue 25: Struct field crushed
	// issues.issue25()
	// // Issue 26: Failed to modify value in an array
	// issues.issue26()
	// // Issue 27: Panic when trying to index (using a var) an array, member of a struct passed as a function argument
	// issues.issue27()
	// // Issue 28: Can't call method from package
	// issues.issue28()
	// // Issue 29: Can't call method if it has a parameter
	// issues.issue29()
	// // Issue 30: Panic when using arithmetic to index an array field of a struct
	// issues.issue30()
	// // Issue 35: Panic when accessing property of struct array passed in as argument to func
	// issues.issue35()
	// // Issue 37: Unexpected results when accessing arrays of structs in a struct
	// issues.issue37()

	// var endIssues i64
	// endIssues = time.UnixNano()

	// // counting successful tests
	// successfulTests = 0
	// // res = []bool{}
	// for c := 0; c < len(res); c++ {
	// 	if res[c] {
	// 		successfulTests = successfulTests + 1
	// 	}
	// }

	// printf("Tests finished after %d nanoseconds (%f milliseconds)\n\n", i64.sub(endIssues, startIssues), f64.div(i64.f64(endIssues - startIssues), 1000000.0D))
	// printf("A total of %d tests were performed\n", len(res))
	// printf("%d were successful\n", successfulTests)
	// printf("%d failed\n", len(res) - successfulTests)
}
